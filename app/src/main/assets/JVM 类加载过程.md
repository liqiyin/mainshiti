### 链接

<https://troywu0.gitbooks.io/spark/content/java%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6.html>

---

类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载，连接（验证，准备，解析），初始化，使用，卸载。

### 5种情况下必须对类进行初始化：

1. 遇到new，getstatic,putstatic,invokestatic这4条字节码时候，如果类没有进行初始化，则需要先触发其初始化
2. 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化
3. 当初始化一个类的时候，发现它的父类还没有初始化，则先触发父类的初始化
4. 当虚拟机启动时，用户需要指定一个要执行的主类（包含main（）方法的类），虚拟机会先初始化这个类
5. 当使用JDK1.7的动态语言支持时候，如果一个java.lang.invoke.MethodHandle实例最后解析结果为REF_getstatic,REF_putstatic,REF_invokeStatic的方法句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化

### 加载器分类

从java虚拟机的角度来讲，只存在两种不同的类加载器：
* 一种是启动类加载器（bootstrap classloader），这个类加载器使用C++语言实现的，是虚拟机自身的一部分；
* 另一种就是所有其他的类加载器，这些类都是有java语言实现的，独立于虚拟机外部，并且 全部继承自抽象类java.lang.ClassLoader。

### 在加载阶段，java虚拟机需要完成以下3件事：

1. 通过一个类的全限定名来获取定义此类的二进制字节流。
2. 将定义类的二进制字节流所代表的静态存储结构转换为方法区的运行时数据结构。
3. 在java堆中生成一个代表该类的java.lang.Class对象，作为方法区数据的访问入口。

### 类加载器按照层次，从顶层到底层，分为以下三种：

#### 启动类加载器（Bootstrap ClassLoader）

用来加载 Java 的核心库，是用原生代码来实现的，并不继承自 java.lang.ClassLoader。

这个类加载器负责将存放在JAVA_HOME/lib下的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。启动类加载器无法被Java程序直接引用。

#### 扩展类加载器（Extension ClassLoader）

用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。

这个加载器负责加载JAVA_HOME/lib/ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器

#### 应用程序类加载器（Application ClassLoader）

它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。

这个加载器是ClassLoader中getSystemClassLoader()方法的返回值，所以一般也称它为系统类加载器。它负责加载用户类路径（Classpath）上所指定的类库，可直接使用这个加载器，如果应用程序没有自定义自己的类加载器，一般情况下这个就是程序中默认的类加载器

![classLoader](https://troywu0.gitbooks.io/spark/content/assets/classLoader.png)

### 类加载的双亲委派模型

双亲委派模型要求除了顶层的启动类加载器外，其他的类加载器都应当有自己的父类加载器。这里类加载器之间的父子关系一般不会以继承关系来实现，而是都使用组合关系来复用父加载器的代码

工作过程：

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传递到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载

好处：

Java类随着它的类加载器一起具备了一种带有优先级的层次关系。例如类Object，它放在rt.jar中，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类

判断两个类是否相同是通过classloader.class这种方式进行的，所以哪怕是同一个class文件如果被两个classloader加载，那么他们也是不同的类
