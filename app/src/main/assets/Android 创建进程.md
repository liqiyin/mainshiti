### 链接

[Android 中的多进程，你值得了解的一些知识](http://yifeng.studio/2017/06/16/android-multi-process-things/index.html)  
[Android多进程介绍](http://blog.spinytech.com/2016/11/15/android_multiple_process/)

---

### 关于进程

大家知道，一个应用中通常包含多个线程，用于处理耗时任务，防止 ANR 之类的错误。但是一个应用其实也能包含多个进程，只是一般用不到而已。

由于 Android 系统特有的机制，会为每个 App 单独分配一个进程，同时赋予一定大小的内存供其使用。这样，进程之间，或者说 App 之间都是独立运行的，彼此不会互相影响。

那么这么多进程争夺系统内存等资源，而系统资源是有限的，怎么办呢？别急，有进程优先级。当系统内存资源不足时，为了保证高优先级的进程能够顺畅使用，那些低优先级的进程很容易被系统杀掉，从而释放资源。

### 为什么要使用多进程

通常，我们应用中的 Activity、Service 等四大组件默认都位于一个进程里面，并且这个进程名称的默认值就是我们给应用定义的包名。既然有了一个默认的进程，为什么还要使用多进程呢？

前面我们说道，系统为每个进程分配的内存是有限的，比如在以前的低端手机上常见是 16M，现在的机器内存更大一些，32M、48M，甚至更高。但是，总是有限的，毕竟一个手机出厂之后 RAM 的大小就定了，总是无法满足所有应用的需求。

当然，你可以在 Application 中通过使用 largeHeap 属性为自己应用所处的进程争取分配更大的内存，就像这样：

```xml
<application
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:largeHeap="true">

    ......

</application>
```

但也存在不够用的可能，一旦超出，马上发生 OOM，内存溢出。

所以，一个明智的选择就是使用多进程，将一些看不见的服务、比较独立而又相当占用内存的功能运行在另外一个进程当中，主动分担主进程的内存消耗。常见如，应用中的推送服务，音乐类 App 的后台播放器等等，单独运行在一个进程中。

使用多进程还有一个好处就是，互相拉起。当然，这显得有些流氓，然而你会发现市场上很多全家桶之类的应用确实是这么做的。某种程度上，这种做法也能够保证自家应用的功能更好地服务用户。

### 如何使用多进程

在项目中使用多进程操作起来非常简单，在 AndroidManafest.xml 清单文件中注册 Activity、Service 等四大组件时，使用 android:process 属性指定进程名即可，如：

```xml
<service
    android:name=".ProcessName"
    android:process=":music"
/>
```

该属性值的命名也是有一定规则的：

* 如果像上面这样，以冒号 “:” 开头，那么该组件所处的进程就是一个 **私有进程** 。当这个组件被启动运行时，该进程随即被创建，并且进程名为应用包名加上这里定义的 ProcessName 名称；
* 如果是以小写字母开头，该进程就是一个 **全局进程**，可以和其他应用共享，减少资源占用。这里的进程名就是属性值定义的这个字符串。

注意：作为 android:process 属性值的字符串，在名称的定义上，必须符合 Android 包名的命名规范。你不能以数字开头，或者大写字母开头等。否则，编译时会报错。

---

## 进程生命周期

Android将重要性层次结构分为5个层级，分为了：

### 前台进程

用户当前操作所必需的进程。如果一个进程满足以下任一条件，即视为前台进程：

* 托管用户正在交互的 Activity（已调用 Activity 的 onResume() 方法）
* 托管某个 Service，后者绑定到用户正在交互的 Activity
* 托管正在“前台”运行的 Service（服务已调用 startForeground()）
* 托管正执行一个生命周期回调的 Service（onCreate()、onStart() 或 onDestroy()）
* 托管正执行其 onReceive() 方法的 BroadcastReceiver

通常，在任意给定时间前台进程都为数不多。只有在内存不足以支持它们同时继续运行这一万不得已的情况下，系统才会终止它们。 此时，设备往往已达到内存分页状态，因此需要终止一些前台进程来确保用户界面正常响应。
这就需要依靠系统的资源。

### 可见进程

没有任何前台组件、但仍会影响用户在屏幕上所见内容的进程。 如果一个进程满足以下任一条件，即视为可见进程：

* 托管不在前台、但仍对用户可见的 Activity（已调用其 onPause() 方法）。例如，如果前台 Activity 启动了一个对话框，允许在其后显示上一 Activity，则有可能会发生这种情况。
* 托管绑定到可见（或前台）Activity 的 Service。

可见进程被视为是极其重要的进程，除非为了维持所有前台进程同时运行而必须终止，否则系统不会终止这些进程。

### 服务进程

正在运行已使用 startService() 方法启动的服务且不属于上述两个更高类别进程的进程。尽管服务进程与用户所见内容没有直接关联，但是它们通常在执行一些用户关心的操作（例如，在后台播放音乐或从网络下载数据）。因此，除非内存不足以维持所有前台进程和可见进程同时运行，否则系统会让服务进程保持运行状态。

### 后台进程

包含目前对用户不可见的 Activity 的进程（已调用 Activity 的 onStop() 方法）。这些进程对用户体验没有直接影响，系统可能随时终止它们，以回收内存供前台进程、可见进程或服务进程使用。 通常会有很多后台进程在运行，因此它们会保存在 LRU （最近最少使用）列表中，以确保包含用户最近查看的 Activity 的进程最后一个被终止。如果某个 Activity 正确实现了生命周期方法，并保存了其当前状态，则终止其进程不会对用户体验产生明显影响，因为当用户导航回该 Activity 时，Activity 会恢复其所有可见状态。

### 空进程

不含任何活动应用组件的进程。保留这种进程的的唯一目的是用作缓存，以缩短下次在其中运行组件所需的启动时间。 为使总体系统资源在进程缓存和底层内核缓存之间保持平衡，系统往往会终止这些进程。
