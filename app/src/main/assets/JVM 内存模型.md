### 链接

<http://gityuan.com/2016/01/09/java-memory/>
<https://www.jianshu.com/p/1579aafac60b>

---

运行时内存数据区大体上被分为 5 个区域、两种类型。

5 个数据区包括：方法区、堆区、虚拟机栈、本地方法栈、程序计数器

![内存模型](https://upload-images.jianshu.io/upload_images/2654250-152293461531f520.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/700)

两种类型:

所有线程共享的数据区：
方法区: 存储已被虚拟机加载的类信息、常量、静态变量、即时编译后代码等数据。常量池位于方法区，并使用永久代来实现方法区
堆区: 我们常说用于存放对象的区域

线程私有 (隔离) 数据区：
虚拟机栈: 方法执行时创建一个栈帧，用于存储局部变量、操作数栈、动态链接、方法出口等信息。每个方法一个栈帧，互不干扰
本地方法栈: 用于存放执行 native 方法的运行数据
程序计数器: 当前线程所执行的字节码的指示器，通过改变计数器来选取下一条需要执行的字节码指令

---

### 程序计数器

程序计数器可看做当前线程所执行字节码行号的指示器。每个线程都有一个独立的程序计数器，各个线程之间计数器互不影响，独立存储。

如果当前线程执行的是 Native 方法，则这个计数器为空。执行 Java 方法时，这个计数器记录执行字节码指令地址。

### 虚拟机栈

虚拟机栈是线程私有的，生命周期和线程的相同。方法在执行的时候，都会有一个栈帧创建出来，用于存储局部变量表、操作数栈、动态链接、方法出口等信息，而这个栈帧就存放在虚拟机栈中。

![虚拟机栈](https://upload-images.jianshu.io/upload_images/2654250-5e9afd3a1dbe1a36.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/569)

进入方法前先会创建栈帧入栈作为栈顶栈帧，然后使用这个栈帧。

同样，方法执行完后栈帧出栈并销毁，继续执行栈中的栈顶栈帧。

### 本地方法栈

虚拟机执行 Native 方法时使用，不同的虚拟机有不同的实现方法，HotSpot 虚拟机的本地方法栈和虚拟机栈合二为一。

### Java 堆区

该区域被所有线程共享，所有创建的对象都在这个区域分配内存并初始化。

### 方法区

用于存放虚拟机加载的信息、常量、静态变量、即时编译器编译后的代码等数据。

由于永久代存储的数据生命周期非常长，GC 在这个区域消耗时间长且回收效果差，所以方法区 GC 频率很低。

### 方法区中的常量池

又称运行时常量池，是方法区的一部分。用于存放编译器生成的各种字面量和符号引用。除外，运行期间新的常量也会放入常量池中。常见运行时常量池添加是通过 String 类的 intern() 方法。

1. 字面量：如文本字符串、final 的常量值
2. 符号引用：编译语言层面的概念，包括以下 3 类：
    * 类和接口的全限定名
    * 字段的名称和描述符
    * 方法的名称和描述符

因为这部分是方法区的一个部分，所以使用空间受到方法区的影响。
